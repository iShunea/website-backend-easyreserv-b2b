{"file_contents":{"schemas/form-alert.js":{"content":"const mongoose = require('mongoose');\n\nconst formAlertSchema = new mongoose.Schema({\n    email: { type: String, required: true, unique: true },\n    fullName: { type: String, required: true },\n    filePath: { type: String, required: true },\n    shortMessage: { type: String },\n    errorType: { type: String, required: true }\n});\n\nconst FormAlert = mongoose.model('Form Alert', formAlertSchema);\nmodule.exports = FormAlert;\n","size_bytes":422},"schemas/job.js":{"content":"const mongoose = require('mongoose');\n\n// Define the Job schema\nconst jobSchema = new mongoose.Schema({\n  id: { type: String, required: true, unique: true },\n  isInternship: { type: Boolean, required: true },\n  jobTitle: { type: String, required: true },\n  location: { type: String, required: true },\n  metaKeywords: { type: String, required: true },\n  metaDescription: { type: String, required: true },\n  type: { type: String, required: true },\n  date: { type: String, required: true },\n  firstSectionHeading: { type: String, required: true },\n  firstSectionList: [String],\n  secondSectionHeading: { type: String, required: true},\n  secondSectionList: [String],\n  thirdSectionHeading: { type: String, required: true},\n  thirdSectionList: [String],\n  fourthSectionHeading: { type: String, required: true},\n  fourthSectionList: [String],\n  baseUrl: { type: String, required: true },\n});\n\n// Create and export the Job model\nconst Job = mongoose.model('Job', jobSchema);\nmodule.exports = Job;","size_bytes":989},"schemas/work.js":{"content":"const mongoose = require('mongoose');\n\n// Define the sub-schema for project columns (firstColumnProjects, secondColumnProjects, etc.)\nconst ProjectSchema = new mongoose.Schema({\n    imagePath: { type: String, required: true },\n    title: { type: String, required: true }\n}, { _id: false });\n\n// Define the sub-schema for review\nconst ReviewSchema = new mongoose.Schema({\n    text: { type: String, required: true },\n    author: { type: String, required: true },\n    position: { type: String, required: true },\n    imageSrc: { type: String, required: true }\n}, { _id: false });\n\n// Main Schema\nconst WorkSchema = new mongoose.Schema({\n    id: { type: String, required: true, unique: true },\n    metaKeywords: { type: String, required: true },\n    metaDescription: { type: String, required: true },\n    titleImagePath: { type: String, required: true },\n    imageLabelSrc: { type: String, required: true },\n    workTags: { type: [String], required: true }, // Array of strings\n    baseUrl: { type: String, required: true },\n    title: { type: String, required: true },\n    titleParagraph: { type: String, required: true },\n    visitWebsiteLink: { type: String, required: true },\n    callToActionTitle: { type: String, required: true },\n    callToActionParagraph: { type: String, required: true },\n    \n    // Arrays for project columns\n    firstColumnProjects: { type: [ProjectSchema], required: true },\n    secondColumnProjects: { type: [ProjectSchema], required: true },\n    thirdColumnProjects: { type: [ProjectSchema], required: true },\n    fourthColumnProjects: { type: [ProjectSchema], required: true },\n\n    // Review section\n    review: { type: ReviewSchema, required: true }\n});\n\n// Model creation\nconst Work = mongoose.model('Work', WorkSchema);\n\nmodule.exports = Work;\n","size_bytes":1776},"schemas/form-call.js":{"content":"const mongoose = require('mongoose');\n\nconst formCallSchema = new mongoose.Schema({\n    email: { type: String, required: true, unique: true },\n    phone: { type: String, required: true },\n    fullName: { type: String, required: true },\n    filePath: { type: String, required: true },\n    shortMessage: { type: String },\n    projectType: { type: String, required: true }\n});\n\nconst FormCall = mongoose.model('Form Call', formCallSchema);\nmodule.exports = FormCall;\n","size_bytes":464},"server.js":{"content":"require('dotenv').config(); // Load environment variables from .env file\nconst express = require('express');\nconst connectDB = require('./db');\nconst cors = require('cors');\nconst path = require('path');\nconst blogsRoutes = require('./enpoints/blogs'); // Import the blogs routes\nconst jobsRoutes = require('./enpoints/jobs'); // Import the jobs routes\nconst worksRoutes = require('./enpoints/works'); // Import the works routes\nconst teamRoutes = require('./enpoints/team'); // Import the team routes\nconst servicesRoutes = require('./enpoints/services'); // Import the services routes\nconst formsRoutes = require('./enpoints/forms');\nconst authRoutes = require('./enpoints/auth'); // Import the auth routes\n\n// Initialize express\nconst app = express();\napp.use(cors());\n\n// Serve static files from the 'images' directory\napp.use('/images', express.static(path.join(__dirname, 'images')));\napp.use(express.json());\n\n// Connect to MongoDB\nconnectDB(); // Call the connection function\n\n// Use the blogs routes\napp.use('/', blogsRoutes);\n\n// Use the jobs routes\napp.use('/', jobsRoutes);\n\n// Use the works routes\napp.use('/', worksRoutes);\n\n// Use the team routes\napp.use('/', teamRoutes);\n\n// Use the services routes\napp.use('/', servicesRoutes);\n\n// Use the forms routes\napp.use('/', formsRoutes);\n\n// Use the auth routes\napp.use('/', authRoutes);\n\n// Start the server\nconst PORT = process.env.SERVER_PORT || 3000;\napp.listen(PORT, 'localhost', () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});","size_bytes":1517},"enpoints/team.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst { uploadTeam, updateObjectWithUploadedFiles } = require('../handleImage');\nconst Team = require('../schemas/team');\nconst path = '/images/team/';\n\n// POST route for team\nrouter.post('/team', uploadTeam.any(), async (req, res) => {\n  try {\n    const teamData = { ...req.body };\n\n    // Iterate over req.files to assign the correct paths to teamData\n    updateObjectWithUploadedFiles(req, teamData, path);\n\n    const newTeam = new Team(teamData);\n    await newTeam.save();\n\n    res.status(201).json({ message: 'Team member created successfully', team: newTeam });\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving team member', error });\n    console.error('Error:', error);\n  }\n});\n\n// GET route to retrieve all jobs\nrouter.get('/team', async (req, res) => {\n    try {\n      const team = await Team.find();\n      res.status(200).json(team);\n    } catch (error) {\n      res.status(500).json({ message: 'Error retrieving team', error });\n      console.error(\"Error: \", error);\n    }\n  }\n);\n  \n// GET route to retrieve all team for team page\nrouter.get('/admin/team/list', async (req, res) => {\n  try {\n      // Use projection to only retrieve 'id' and 'jobTitle' fields\n      const team = await Team.find({}, 'id fullName');\n\n      // Use .map() to efficiently transform the result\n      const returnTeam = team.map(({ id, fullName }) => ({\n          id,\n          fullName,\n      }));\n\n      res.status(200).json(returnTeam);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving team', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single team by ID\nrouter.get('/admin/edit/team/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const team = await Team.findOne({ id: id });\n\n    if (!team) {\n      return res.status(404).json({ message: 'Team not found' });\n    }\n\n    res.status(200).json(team);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the team', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n\n// PUT route to update an team\nrouter.put('/admin/edit/team/:id', uploadTeam.any(), async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const blogData = { ...req.body };\n\n    updateObjectWithUploadedFiles(req, blogData, path);\n    \n    const updatedService = await Team.findOneAndUpdate({ id: id }, blogData, { new: true });\n\n    if (!updatedService) {\n      return res.status(404).json({ message: 'Team not found' });\n    }\n\n    res.status(200).json({ message: 'Team updated successfully', team: updatedService });\n  } catch (error) {\n    res.status(500).json({ message: 'Error updating team', error });\n    console.error('Error:', error);\n  }\n});\n\nmodule.exports = router;","size_bytes":2799},"README.md":{"content":"# ishunea-backend","size_bytes":17},"enpoints/works.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst { uploadWork, updateObjectWithUploadedFiles } = require('../handleImage');\nconst Work = require('../schemas/work');\nconst path = '/images/work/'\n\n// POST route for work\nrouter.post('/works', uploadWork.any(), async (req, res) => {\n  try {\n    const workData = { ...req.body };\n\n    updateObjectWithUploadedFiles(req, workData, path);\n\n    const newWork = new Work(workData);\n    await newWork.save();\n\n    res.status(201).json({ message: 'Work created successfully', work: newWork });\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving work', error });\n    console.error('Error:', error);\n  }\n});\n\n// GET route to retrieve all works for works page\nrouter.get('/admin/works/list', async (req, res) => {\n  try {\n      // Use projection to only retrieve 'id' and 'jobTitle' fields\n      const works = await Work.find({}, 'id title');\n\n      // Use .map() to efficiently transform the result\n      const returnWorks = works.map(({ id, title }) => ({\n          id,\n          title,\n      }));\n\n      res.status(200).json(returnWorks);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving works', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve all works page\nrouter.get('/works', async (req, res) => {\n  try {\n    const works = await Work.find();\n    res.status(200).json(works);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving works', error });\n    console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve all works\nrouter.get('/works/tags', async (req, res) => {\n  try {\n    // Use projection to retrieve only the necessary fields\n    const uniqueTags = await Work.distinct('workTags');\n\n    res.status(200).json(uniqueTags);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving works tags', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single work by ID\nrouter.get('/admin/edit/works/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const work = await Work.findOne({ id: id });\n\n    if (!work) {\n      return res.status(404).json({ message: 'Work not found' });\n    }\n\n    res.status(200).json(work);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the work', error });\n    console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single work by ID\nrouter.get('/works/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const work = await Work.findOne({ id: id });\n\n    if (!work) {\n      return res.status(404).json({ message: 'Work not found' });\n    }\n\n    res.status(200).json(work);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the work', error });\n    console.error(\"Error: \", error);\n  }\n});\n\n// PUT route to update an work\nrouter.put('/admin/edit/works/:id', uploadWork.any(), async (req, res) => {\nconst { id } = req.params;\ntry {\n  const blogData = { ...req.body };\n\n  updateObjectWithUploadedFiles(req, blogData, path);\n  \n  const updatedService = await Work.findOneAndUpdate({ id: id }, blogData, { new: true });\n\n  if (!updatedService) {\n    return res.status(404).json({ message: 'Work not found' });\n  }\n\n  res.status(200).json({ message: 'Work updated successfully', work: updatedService });\n} catch (error) {\n  res.status(500).json({ message: 'Error updating work', error });\n  console.error('Error:', error);\n}\n});\n\nmodule.exports = router;","size_bytes":3513},"handleFiles.js":{"content":"const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst { v4: uuidv4 } = require('uuid');\n\n// Create the storage configuration for 'files' directory\nconst createMulterStorage = () => {\n    const dir = './files'; // Use 'files' as the upload directory\n\n    // Create directory if it doesn't exist\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n    }\n\n    return multer.diskStorage({\n        destination: (req, file, cb) => {\n            cb(null, dir); // Set destination to 'files' directory\n        },\n        filename: (req, file, cb) => {\n            // Create a unique filename using UUID and original file extension\n            const uniqueName = uuidv4() + path.extname(file.originalname);\n            cb(null, uniqueName);\n            console.log(`File saved: ${uniqueName}`);\n        }\n    });\n};\n\n// File filter for PDFs and DOCX files\nconst fileFilter = (req, file, cb) => {\n    const allowedTypes = [\n        'application/pdf',\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n    ];\n    if (allowedTypes.includes(file.mimetype)) {\n        cb(null, true); // Accept file if type matches\n    } else {\n        cb(new Error('Only PDF and DOCX files are allowed'), false); // Reject file\n    }\n};\n\n// Multer instance with storage and file filter\nconst uploadFiles = multer({ \n    storage: createMulterStorage(),\n    fileFilter: fileFilter\n}).single('filePath'); // Specify the field here\n\nconst updateFilesPath = (formData) => {\n    if (formData.filePath) {\n        formData.filePath = '/' + formData.filePath.replace(/\\\\/g, '/');\n    }\n}\n\n// Exporting the configured multer instance\nmodule.exports = { uploadFiles, updateFilesPath };\n","size_bytes":1782},"enpoints/forms.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst EmailNotification = require('../schemas/email-notification');\nconst { uploadNone } = require('../handleImage');\nconst { uploadFiles, updateFilesPath } = require('../handleFiles');\nconst FormJob = require('../schemas/form-job');\nconst FormCall = require('../schemas/form-call');\nconst FormAlert = require('../schemas/form-alert');\n\n// POST route for form\n// Totul se incepe cu /forms\n\nrouter.post('/forms/email-notification', uploadNone, async (req, res) => {\n  try {\n    const formData = { ...req.body };\n\n    if (!isValidEmail(formData.email)) {\n        return res.status(400).json({ message: 'Invalid email' });\n    }\n\n    const email = new EmailNotification(formData);\n    await email.save();\n\n    res.status(200).json({ message: 'Email was successfully registered', email });\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving user email', error });\n    console.error('Error:', error);\n  }\n})\n\nrouter.post('/forms/job', uploadFiles, async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ message: 'No file uploaded or invalid file type' });\n    }\n\n    const formData = { ...req.body, filePath: req.file.path };\n\n    updateFilesPath(formData);\n\n    if (!formData) {\n      return res.status(400).json({ message: 'No form data provided' });\n    }\n\n    if (!isValidEmail(formData.email)) {\n      return res.status(400).json({ message: 'Invalid email' });\n    }\n    \n    if (!isValidFullName(formData.fullName)) {\n      return res.status(400).json({ message: 'Invalid full name' });\n    }\n\n    if (!isValidMessage(formData.shortMessage)) {\n      return res.status(400).json({ error: 'Invalid message format.' });\n    }\n\n    if (!isValidPhoneNumber(formData.phone)) {\n      return res.status(400).json({ message: 'Invalid phone number' });\n    }\n\n    const formJob = new FormJob(formData);\n    await formJob.save();\n\n    res.status(200).json({ message: 'Form job is saved successfully!'});\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving form job', error });\n    console.error('Error:', error);\n  }\n})\n\nrouter.post('/forms/call', uploadFiles, async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ message: 'No file uploaded or invalid file type' });\n    }\n\n    const formData = { ...req.body, filePath: req.file.path };\n\n    updateFilesPath(formData);\n\n    if (!formData) {\n      return res.status(400).json({ message: 'No form data provided' });\n    }\n\n    if (!isValidEmail(formData.email)) {\n      return res.status(400).json({ message: 'Invalid email' });\n    }\n    \n    if (!isValidFullName(formData.fullName)) {\n      return res.status(400).json({ message: 'Invalid full name' });\n    }\n\n    if (!isValidMessage(formData.shortMessage)) {\n      return res.status(400).json({ error: 'Invalid message format.' });\n    }\n\n    if (!isValidMessage(formData.projectType)) {\n      return res.status(400).json({ error: 'Invalid message of project type format.' });\n    }\n\n    if (!isValidPhoneNumber(formData.phone)) {\n      return res.status(400).json({ message: 'Invalid phone number' });\n    }\n\n    const formCall = new FormCall(formData);\n    await formCall.save();\n\n    res.status(200).json({ message: 'Form call is saved successfully!'});\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving form call', error });\n    console.error('Error:', error);\n  }\n})\n\nrouter.post('/forms/alert', uploadFiles, async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ message: 'No file uploaded or invalid file type' });\n    }\n\n    const formData = { ...req.body, filePath: req.file.path };\n\n    updateFilesPath(formData);\n\n    if (!formData) {\n      return res.status(400).json({ message: 'No form data provided' });\n    }\n\n    if (!isValidEmail(formData.email)) {\n      return res.status(400).json({ message: 'Invalid email' });\n    }\n    \n    if (!isValidFullName(formData.fullName)) {\n      return res.status(400).json({ message: 'Invalid full name' });\n    }\n\n    if (!isValidMessage(formData.shortMessage)) {\n      return res.status(400).json({ error: 'Invalid message format.' });\n    }\n\n    if (!isValidMessage(formData.errorType)) {\n      return res.status(400).json({ error: 'Invalid message of error type format.' });\n    }\n\n    const formAlert = new FormAlert(formData);\n    await formAlert.save();\n\n    res.status(200).json({ message: 'Form alert is saved successfully!'});\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving form alert', error });\n    console.error('Error:', error);\n  }\n})\n\nfunction isValidEmail(email) {\n  const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return regex.test(email);\n};\n\nfunction isValidFullName(fullName) {\n  const regex = /^[a-zA-Z]+([ '-][a-zA-Z]+)*$/;\n  return regex.test(fullName);\n};\n\n\nfunction isValidMessage(message) {\n  const shortMessageRegex = /^[a-zA-Z0-9 .,!?'-]{1,255}$/;\n  return shortMessageRegex.test(message);\n}\n\nfunction isValidPhoneNumber(phone) {\n  const phoneRegex = /^\\+?(\\d{1,3})?[-.\\s]?(\\(?\\d{1,4}\\)?)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}$/;\n  return phoneRegex.test(phone);\n}\n\n\nmodule.exports = router;","size_bytes":5235},"enpoints/blogs.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst { uploadBlogs, updateObjectWithUploadedFiles } = require('../handleImage');\nconst Blog = require('../schemas/blog');\nconst path = '/images/blogs/';\n\n// POST route for blogs\nrouter.post('/blogs', uploadBlogs.any(), async (req, res) => {\n    try {\n        const blogData = { ...req.body };\n\n        updateObjectWithUploadedFiles(req, blogData, path);\n\n        const newBlog = new Blog(blogData);\n        await newBlog.save();\n\n        res.status(201).json({ message: 'Blog created successfully', blog: newBlog });\n    } catch (error) {\n        res.status(500).json({ message: 'Error saving blog', error });\n        console.error('Error:', error);\n    }\n});\n\n// GET route to retrieve all blogs\nrouter.get('/blogs', async (req, res) => {\n    try {\n      const blogs = await Blog.find(); // Fetch all blogs from the database\n  \n      if (!blogs || blogs.length === 0) {\n        return res.status(404).json({ message: 'No blogs found' });\n      }\n  \n      res.status(200).json(blogs); // Send all blogs as JSON response\n    } catch (error) {\n      res.status(500).json({ message: 'Error retrieving blogs', error });\n      console.error('Error:', error);\n    }\n  }\n);\n\n// GET route to retrieve all blogs\nrouter.get('/blogs/tags', async (req, res) => {\n  try {\n      // Use projection to retrieve only the necessary fields\n      const uniqueTags = await Blog.distinct('label');\n\n      res.status(200).json(uniqueTags);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving blogs tags', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve all blogs for services page\nrouter.get('/admin/blogs/list', async (req, res) => {\n  try {\n      // Use projection to only retrieve 'id' and 'jobTitle' fields\n      const blogs = await Blog.find({}, 'id jobTitle');\n\n      // Use .map() to efficiently transform the result\n      const returnBlogs = blogs.map(({ id }) => ({ id }));\n\n      res.status(200).json(returnBlogs);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving blogs', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single blog by ID\nrouter.get('/blogs/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const blog = await Blog.findOne({ id: id });\n\n    if (!blog) {\n      return res.status(404).json({ message: 'Blog not found' });\n    }\n\n    res.status(200).json(blog);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the blog', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n  \n// GET route to retrieve a single blog by ID\nrouter.get('/admin/edit/blogs/:id', async (req, res) => {\n    const { id } = req.params;\n  \n    try {\n      const blog = await Blog.findOne({ id: id });\n  \n      if (!blog) {\n        return res.status(404).json({ message: 'Blog not found' });\n      }\n  \n      res.status(200).json(blog);\n    } catch (error) {\n      res.status(500).json({ message: 'Error retrieving the blog', error });\n      console.error(\"Error: \", error);\n    }\n  }\n);\n\n// PUT route to update an blog\nrouter.put('/admin/edit/blogs/:id', uploadBlogs.any(), async (req, res) => {\n  const { id } = req.params;\n  try {\n    const blogData = { ...req.body };\n\n    updateObjectWithUploadedFiles(req, blogData, path);\n    \n    const updatedService = await Blog.findOneAndUpdate({ id: id }, blogData, { new: true });\n\n    if (!updatedService) {\n      return res.status(404).json({ message: 'Blog not found' });\n    }\n\n    res.status(200).json({ message: 'Blog updated successfully', blog: updatedService });\n  } catch (error) {\n    res.status(500).json({ message: 'Error updating blog', error });\n    console.error('Error:', error);\n  }\n});\n\nmodule.exports = router;","size_bytes":3790},"db.js":{"content":"// db.js\n\nconst mongoose = require('mongoose');\nrequire('dotenv').config(); // Load environment variables from .env file\n\n// MongoDB connection function\nconst connectDB = async () => {\n  const uri = process.env.MONGO_DB;\n  try {\n    await mongoose.connect(uri);\n    console.log('MongoDB connected successfully');\n  } catch (err) {\n    console.error('MongoDB connection error:', err);\n    process.exit(1); // Exit the process with failure if the connection fails\n  }\n};\n\nmodule.exports = connectDB;\n","size_bytes":498},"schemas/blog.js":{"content":"const mongoose = require('mongoose');\n\nconst blogSchema = new mongoose.Schema({\n  id: { type: String, required: true, unique: true },\n  baseUrl: { type: String, required: true },\n  metaKeywords: { type: String, required: true },\n  metaDescription: { type: String, required: true },\n  blogTitle: { type: String, required: true },\n  publishingDate: { type: String, required: true },\n  label: { type: String, required: true },\n  titleImagePath: { type: String, required: true },\n  blogIntro: { type: String, required: true },\n  firstSubheadingTitle: { type: String, required: true },\n  firstSubheadingFirstText: { type: String, required: true },\n  carouselImagePath1: { type: String, required: true },\n  carouselImagePath2: { type: String, required: true },\n  carouselImagePath3: { type: String, required: true },\n  carouselImagePath4: { type: String, required: true },\n  firstSubheadingSecondText: { type: String, required: true },\n  firstSubheadingImage: { type: String, required: true },\n  firstSubheadingImageDescription: { type: String, required: true },\n  secondSubheadingTitle: { type: String, required: true },\n  secondSubheadingFirstText: { type: String, required: true }\n});\n\nconst Blog = mongoose.model('Blog', blogSchema);\nmodule.exports = Blog;\n","size_bytes":1255},"schemas/form-job.js":{"content":"const mongoose = require('mongoose');\n\nconst formJobSchema = new mongoose.Schema({\n    email: { type: String, required: true, unique: true },\n    phone: { type: String, required: true },\n    fullName: { type: String, required: true },\n    filePath: { type: String, required: true },\n    shortMessage: { type: String }\n});\n\nconst FormJob = mongoose.model('Form Job', formJobSchema);\nmodule.exports = FormJob;\n","size_bytes":408},"schemas/team.js":{"content":"const mongoose = require('mongoose');\nconst AutoIncrement = require('mongoose-sequence')(mongoose);\n\nconst socialMediaSchema = new mongoose.Schema({\n  facebook: { type: String, required: true },\n  linkedin: { type: String, required: true },\n  twitter: { type: String, required: true }\n});\n\nconst teamSchema = new mongoose.Schema({\n  id: { type: Number },\n  fullName: { type: String, required: true },\n  metaKeywords: { type: String, required: true },\n  metaDescription: { type: String, required: true },\n  job: { type: String, required: true },\n  imageSrc: { type: String, required: true },\n  socialMedia: { type: socialMediaSchema, required: true }\n});\n\nteamSchema.plugin(AutoIncrement, { inc_field: 'id' });\n\nconst Team = mongoose.model('Team', teamSchema);\nmodule.exports = Team;\n","size_bytes":783},"handleImage.js":{"content":"const multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst { v4: uuidv4 } = require('uuid');\n\n// Function to create multer storage based on the directory\nconst createMulterStorage = (subDir) => {\n    const dir = `./images/${subDir}`; // Dynamic directory based on the subDir parameter\n    // Create directory if it doesn't exist\n    if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n    }\n\n    return multer.diskStorage({\n        destination: (req, file, cb) => {\n            cb(null, dir);\n        },\n        filename: (req, file, cb) => {\n            const uniqueName = uuidv4() + path.extname(file.originalname); \n            cb(null, uniqueName);\n            console.log(`File created: ${uniqueName}`);\n        }\n    });\n};\n\n// Middleware to filter out files that already exist\nconst checkExistingFiles = (subDir) => (req, file, cb) => {\n    const dir = `./images/${subDir}`;\n    const filePath = path.join(dir, file.originalname);\n    \n    if (fs.existsSync(filePath)) {\n        console.log(`File already exists: ${file.originalname}`);\n        cb(null, false);  // Reject the file upload\n    } else {\n        cb(null, true);   // Accept the file upload\n    }\n};\n\n// Function to delete files\nconst deleteUploadedFiles = (files) => {\n    files.forEach((file) => {\n        const filePath = path.join(__dirname, file.path);\n        fs.unlink(filePath, (err) => {\n            if (err) {\n                console.error('Failed to delete file:', filePath, err);\n            } else {\n                console.log('Successfully deleted file:', filePath);\n            }\n        });\n    });\n};\n\nfunction updateObjectWithUploadedFiles(req, inputObject, path) {\n    // Helper function to set the value at the correct path dynamically\n    const setObjectValueByPath = (obj, pathString, value) => {\n        const pathArray = pathString\n            .replace(/\\[(\\w+)\\]/g, '.$1') // Convert '[0]' or '[imagePath]' to '.0' or '.imagePath'\n            .split('.'); // Split by dot notation\n        \n        pathArray.reduce((acc, key, idx) => {\n            if (idx === pathArray.length - 1) {\n                // Last key, assign the value here\n                acc[key] = value;\n            } else {\n                // Navigate through nested object/array\n                if (!acc[key]) {\n                    acc[key] = isNaN(Number(pathArray[idx + 1])) ? {} : []; // Choose {} or [] based on next key\n                }\n                return acc[key];\n            }\n        }, obj);\n    };\n\n    if (!req.files) return;\n\n    req.files.forEach(file => {\n        const filePath = path + file.filename;\n        setObjectValueByPath(inputObject, file.fieldname, filePath);\n    });\n}\n\n// Multer instance for handling uploads for jobs, work, services, etc.\nconst uploadJobs = multer({ storage: createMulterStorage('jobs'), fileFilter: checkExistingFiles('jobs') });\nconst uploadWork = multer({ storage: createMulterStorage('work'), fileFilter: checkExistingFiles('work') });\nconst uploadBlogs = multer({ storage: createMulterStorage('blogs'), fileFilter: checkExistingFiles('blogs') });\nconst uploadTeam = multer({ storage: createMulterStorage('team'), fileFilter: checkExistingFiles('team') });\n// Multer instance with file filter to skip existing files\nconst uploadServices = multer({ \n    storage: createMulterStorage('services'),\n    fileFilter: checkExistingFiles('services')\n});\nconst uploadNone = multer().none();\n\nmodule.exports = {\n    uploadJobs,\n    uploadWork,\n    uploadBlogs,\n    uploadTeam,\n    uploadNone,\n    uploadServices,\n    updateObjectWithUploadedFiles,\n    deleteUploadedFiles\n}","size_bytes":3642},"schemas/email-notification.js":{"content":"const mongoose = require('mongoose');\n\nconst emailNotificationSchema = new mongoose.Schema({\n    email: { type: String, required: true, unique: true }\n})\n\nconst EmailNotification = mongoose.model('Email Notification', emailNotificationSchema);\nmodule.exports = EmailNotification;","size_bytes":279},"schemas/service.js":{"content":"const mongoose = require('mongoose');\n\nconst serviceSchema = new mongoose.Schema({\n  id: { type: String, required: true, unique: true },\n  baseUrl: { type: String, required: true },\n  title: { type: String, required: true },\n  metaKeywords: { type: String, required: true },\n  metaDescription: { type: String, required: true },\n  imageLabelSrc: { type: String, required: true },\n  firstIconPath: { type: String, required: true },\n  firstIconTitle: { type: String, required: true },\n  firstIconDescription: { type: String, required: true },\n  secondIconPath: { type: String, required: true },\n  secondIconTitle: { type: String, required: true },\n  secondIconDescription: { type: String, required: true },\n  imageTitlePath: { type: String, required: true },\n  imageTitle: { type: String, required: true },\n  imageTitleDescription: { type: String, required: true },\n  titleDescription: { type: String, required: true }\n});\n\nconst Service = mongoose.model('Service', serviceSchema);\nmodule.exports = Service;\n","size_bytes":1005},"enpoints/services.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst { uploadServices, updateObjectWithUploadedFiles } = require('../handleImage');\nconst Service = require('../schemas/service');\nconst path = '/images/services/';\n\n// POST route for services\nrouter.post('/services', uploadServices.any(), async (req, res) => {\n  try {\n    const servicesData = { ...req.body };\n\n    updateObjectWithUploadedFiles(req, servicesData, path);\n\n    const newService = new Service(servicesData);\n    await newService.save();\n\n    res.status(201).json({ message: 'Service created successfully', service: newService });\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving service', error });\n    console.error('Error:', error);\n  }\n});\n\n// GET route to retrieve all services page\nrouter.get('/services', async (req, res) => {\n    try {\n      const services = await Service.find();\n      res.status(200).json(services);\n    } catch (error) {\n      res.status(500).json({ message: 'Error retrieving services', error });\n      console.error(\"Error: \", error);\n    }\n  }\n);\n\n// GET route to retrieve a single service by ID\nrouter.get('/services/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const service = await Service.findOne({ id: id });\n\n    if (!service) {\n      return res.status(404).json({ message: 'Service not found' });\n    }\n\n    res.status(200).json(service);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the service', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n\n// GET route to retrieve all services except the one ID is passed\nrouter.get('/services/other/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    // Find all services except the one with the given id\n    const services = await Service.find({ id: { $ne: id } });\n\n    if (!services || services.length === 0) {\n      services = [];\n    }\n\n    res.status(200).json(services);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving services', error });\n    console.error(\"Error: \", error);\n  }\n});\n\n  \n// GET route to retrieve all services for services page\nrouter.get('/admin/services/list', async (req, res) => {\n  try {\n      // Use projection to only retrieve 'id' and 'jobTitle' fields\n      const services = await Service.find({}, 'id title');\n\n      // Use .map() to efficiently transform the result\n      const returnServices = services.map(({ id, title }) => ({\n          id,\n          title,\n      }));\n\n      res.status(200).json(returnServices);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving services', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single service by ID\nrouter.get('/admin/edit/services/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const service = await Service.findOne({ id: id });\n    \n    if (!service) {\n      return res.status(404).json({ message: 'Service not found' });\n    }\n\n    \n    res.status(200).json(service);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the service', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n\n// PUT route to update an service\nrouter.put('/admin/edit/services/:id', uploadServices.any(), async (req, res) => {\n  const { id } = req.params;\n  try {\n    const serviceData = { ...req.body };\n\n    updateObjectWithUploadedFiles(req, serviceData, path);\n    \n    const updatedService = await Service.findOneAndUpdate({ id: id }, serviceData, { new: true });\n\n    if (!updatedService) {\n      return res.status(404).json({ message: 'Service not found' });\n    }\n\n    res.status(200).json({ message: 'Service updated successfully', service: updatedService });\n  } catch (error) {\n    res.status(500).json({ message: 'Error updating service', error });\n    console.error('Error:', error);\n  }\n});\n\nmodule.exports = router;","size_bytes":3897},"enpoints/jobs.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst Job = require('../schemas/job');\nconst { uploadNone } = require('../handleImage');\n\n// POST route to add a job\nrouter.post('/jobs', uploadNone, async (req, res) => {\n  try {\n    const jobData = { ...req.body };  // Initialize job data with text fields\n\n    console.log(\"jobData:\", jobData);\n    const newJob = new Job(jobData);\n    await newJob.save();\n\n    res.status(201).json({ message: 'Job created successfully', job: newJob });\n  } catch (error) {\n    res.status(500).json({ message: 'Error saving job', error });\n    console.error('Error:', error);\n  }\n});\n\n// GET route to retrieve all jobs\nrouter.get('/jobs', async (req, res) => {\n    try {\n      const jobs = await Job.find();\n      res.status(200).json(jobs);\n    } catch (error) {\n      res.status(500).json({ message: 'Error retrieving jobs', error });\n      console.error(\"Error: \", error);\n    }\n  }\n);\n\n// GET route to retrieve all jobs\nrouter.get('/jobs/list', async (req, res) => {\n  try {\n      // Use projection to retrieve only the necessary fields\n      const jobs = await Job.find({}, 'id jobTitle date location type isInternship baseUrl');\n\n      // Use .map() to transform the data efficiently\n      const returnJobs = jobs.map(({ id, jobTitle, date, location, type, isInternship, baseUrl }) => ({\n          id,\n          jobTitle,\n          date,\n          country: `${location} · ${type}`,\n          isInternship,\n          baseUrl\n      }));\n\n      res.status(200).json(returnJobs);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving jobs', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single job by ID\nrouter.get('/jobs/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const job = await Job.findOne({ id: id });\n\n    if (!job) {\n      return res.status(404).json({ message: 'Job not found' });\n    }\n\n    res.status(200).json(job);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the job', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n\n// GET route to retrieve all jobs for services page\nrouter.get('/admin/jobs/list', async (req, res) => {\n  try {\n      // Use projection to only retrieve 'id' and 'jobTitle' fields\n      const jobs = await Job.find({}, 'id jobTitle');\n\n      // Use .map() to efficiently transform the result\n      const returnJobs = jobs.map(({ id, jobTitle }) => ({\n          id,\n          jobTitle,\n      }));\n\n      res.status(200).json(returnJobs);\n  } catch (error) {\n      res.status(500).json({ message: 'Error retrieving jobs', error });\n      console.error(\"Error: \", error);\n  }\n});\n\n// GET route to retrieve a single job by ID\nrouter.get('/admin/edit/jobs/:id', async (req, res) => {\n  const { id } = req.params;\n\n  try {\n    const job = await Job.findOne({ id: id });\n\n    if (!job) {\n      return res.status(404).json({ message: 'Job not found' });\n    }\n\n    res.status(200).json(job);\n  } catch (error) {\n    res.status(500).json({ message: 'Error retrieving the job', error });\n    console.error(\"Error: \", error);\n  }\n}\n);\n\n// PUT route to update an job\nrouter.put('/admin/edit/jobs/:id', uploadNone, async (req, res) => {\n  // const path = '/images/jobs/';\n  const { id } = req.params;\n  try {\n    const blogData = { ...req.body };\n\n    const updatedService = await Job.findOneAndUpdate({ id: id }, blogData, { new: true });\n\n    if (!updatedService) {\n      return res.status(404).json({ message: 'Job not found' });\n    }\n\n    res.status(200).json({ message: 'Job updated successfully', job: updatedService });\n  } catch (error) {\n    res.status(500).json({ message: 'Error updating job', error });\n    console.error('Error:', error);\n  }\n});\n\nmodule.exports = router;","size_bytes":3787},"replit.md":{"content":"# iShunea Backend API\n\n## Overview\nThis is the backend API for the iShunea project - a Node.js/Express server that provides REST endpoints for managing blogs, jobs, services, team members, and work portfolio items. The application uses MongoDB Atlas for data storage and supports file uploads for images.\n\n**Current Status:** ✅ Running and connected to MongoDB Atlas\n\n## Project Architecture\n\n### Tech Stack\n- **Runtime:** Node.js v20.19.3\n- **Framework:** Express.js\n- **Database:** MongoDB Atlas\n- **Authentication:** JWT with bcrypt password hashing\n- **File Upload:** Multer\n- **Dependencies:** cors, dotenv, mongoose, mongoose-sequence, uuid, bcryptjs, jsonwebtoken\n\n### Project Structure\n```\n.\n├── server.js              # Main server entry point\n├── db.js                  # MongoDB connection configuration\n├── handleImage.js         # Image upload handling utilities\n├── handleFiles.js         # File handling utilities\n├── enpoints/              # API route handlers\n│   ├── auth.js           # Authentication endpoints\n│   ├── blogs.js          # Blog CRUD operations\n│   ├── forms.js          # Form submissions\n│   ├── jobs.js           # Job postings\n│   ├── services.js       # Services management\n│   ├── team.js           # Team members\n│   └── works.js          # Portfolio works\n├── middleware/            # Express middleware\n│   └── auth.js           # JWT authentication middleware\n├── schemas/               # Mongoose schemas\n│   ├── blog.js\n│   ├── email-notification.js\n│   ├── form-alert.js\n│   ├── form-call.js\n│   ├── form-job.js\n│   ├── job.js\n│   ├── service.js\n│   ├── team.js\n│   ├── user.js           # User authentication schema\n│   └── work.js\n└── images/                # Static file storage\n    ├── blogs/\n    ├── services/\n    ├── team/\n    └── work/\n```\n\n## Configuration\n\n### Environment Variables (Secrets)\n- **MONGO_DB**: MongoDB Atlas connection string\n  - Format: `mongodb+srv://username:password@cluster.mongodb.net/?retryWrites=true&w=majority&appName=appname`\n  - IP Whitelist: 0.0.0.0/0 (allows Replit dynamic IPs)\n- **JWT_SECRET**: Secret key for JWT token signing and verification\n  - Used for authentication token security\n  - Should be a long, random, complex string\n\n### Server Configuration\n- **Port:** 3000 (configurable via SERVER_PORT env variable)\n- **Host:** localhost (backend only)\n- **CORS:** Enabled for all origins\n\n## API Endpoints\n\n### Authentication\n- `POST /api/account/register` - Register new user\n  - Request body: `{ email, password, role }` (role optional, defaults to 'user')\n  - Response: `{ serviceToken, user: { id, email, role, createdAt } }`\n- `POST /api/account/login` - User login\n  - Request body: `{ email, password }`\n  - Response: `{ serviceToken, user: { id, email, role, createdAt } }`\n- `GET /api/account/me` - Get current user (protected route)\n  - Header: `Authorization: Bearer <token>`\n  - Response: `{ user: { id, email, role, createdAt } }`\n\n### Blogs\n- `POST /blogs` - Create new blog\n- `GET /blogs` - Get all blogs\n- `GET /blogs/tags` - Get unique blog tags\n- `GET /blogs/:id` - Get blog by ID\n- `GET /admin/blogs/list` - Get blog list for admin\n- `GET /admin/edit/blogs/:id` - Get blog for editing\n- `PUT /admin/edit/blogs/:id` - Update blog\n\n### Jobs\n- Similar CRUD operations for job postings\n\n### Services\n- Similar CRUD operations for services\n\n### Team\n- Similar CRUD operations for team members\n\n### Works\n- Similar CRUD operations for portfolio works\n\n### Forms\n- Form submission endpoints for contact/applications\n\n## Deployment Notes\n- Database: MongoDB Atlas with 0.0.0.0/0 IP access (required for Replit)\n- Static files served from `/images` directory\n- File uploads handled via Multer with UUID naming\n\n## Recent Changes\n- **2025-10-17**: Added authentication system\n  - Implemented JWT-based authentication with bcrypt password hashing\n  - Created User schema with email, password, and role fields\n  - Added authentication endpoints: /api/account/register, /api/account/login, /api/account/me\n  - Created JWT middleware for protecting routes\n  - Configured JWT_SECRET for token security\n\n- **2024-10-16**: Initial Replit setup\n  - Configured MongoDB Atlas connection\n  - Set up workflow to run backend server\n  - Configured server to bind to localhost:3000\n  - Added IP whitelist 0.0.0.0/0 to MongoDB Atlas for Replit access\n\n## User Preferences\nNone documented yet.\n","size_bytes":4596},"middleware/auth.js":{"content":"const jwt = require('jsonwebtoken');\nconst User = require('../schemas/user');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this-in-production';\n\nconst protect = async (req, res, next) => {\n  let token;\n\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    try {\n      token = req.headers.authorization.split(' ')[1];\n      \n      const decoded = jwt.verify(token, JWT_SECRET);\n      \n      req.user = await User.findById(decoded.id).select('-password');\n      \n      if (!req.user) {\n        return res.status(401).json({ message: 'User not found' });\n      }\n      \n      next();\n    } catch (error) {\n      console.error('Auth middleware error:', error);\n      return res.status(401).json({ message: 'Not authorized, token failed' });\n    }\n  }\n\n  if (!token) {\n    return res.status(401).json({ message: 'Not authorized, no token' });\n  }\n};\n\nconst generateToken = (id) => {\n  return jwt.sign({ id }, JWT_SECRET, {\n    expiresIn: '30d'\n  });\n};\n\nmodule.exports = { protect, generateToken };\n","size_bytes":1055},"schemas/user.js":{"content":"const mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\nconst userSchema = new mongoose.Schema({\n  email: { \n    type: String, \n    required: true, \n    unique: true,\n    lowercase: true,\n    trim: true\n  },\n  password: { \n    type: String, \n    required: true \n  },\n  role: { \n    type: String, \n    enum: ['user', 'admin'],\n    default: 'user'\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) {\n    return next();\n  }\n  \n  const salt = await bcrypt.genSalt(10);\n  this.password = await bcrypt.hash(this.password, salt);\n  next();\n});\n\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return await bcrypt.compare(candidatePassword, this.password);\n};\n\nconst User = mongoose.model('User', userSchema);\nmodule.exports = User;\n","size_bytes":870},"attached_assets/easy_reserv_b_2_b_docs_bundle_1760687855932.md":{"content":"# EasyReserv — Pachet .md (Backend, Admin Panel, Landing B2B, SEO)\n\nMai jos ai **fișierele .md** (într-un singur bundle). Copiază fiecare secțiune într-un fișier separat în repo.\n\n---\n\n## `/docs/backend.md`\n\n### Obiectiv\nBackend expune modele/endpoint‑uri pentru pagini multi‑lingvă, SEO, blocuri de conținut și redirects. Generează automat sitemap și robots.\n\n### Modele (DB)\n- **Page**\n  - `id: string` (slug + locale)\n  - `route: string` (ex. `/pricing`)\n  - `locale: enum(ro|ru|en)`\n  - `slug: string` (fără locale)\n  - `status: enum(draft|published)`\n  - `seo: Seo`\n  - `content: Content`\n  - `createdAt`, `updatedAt`, `publishedAt`, `version`\n- **Seo**\n  - `title: string (≤60)`\n  - `description: string (140–160)`\n  - `robots: enum(index,follow|noindex,nofollow)`\n  - `canonicalOverride?: string (URL absolut)`\n  - `og: { title?, description?, image? }`\n  - `twitter: { card: 'summary_large_image', title?, description?, image? }`\n  - `hreflang: { hrefLang: 'ro'|'ru'|'en'|'x-default', href: string }[]`\n  - `schema: { '@type': string, json: object }[]`\n- **Content**\n  - `blocks: Block[]` (vezi tipurile mai jos)\n- **Block (discriminated union)**\n  - `hero | socialProof | industriesPicker | featuresGrid | integrations | pricingSnippet | faq | ctaBanner`\n- **Redirect**\n  - `from: string`, `to: string`, `code: 301|302`, `date: ISO`\n\n### Endpoint‑uri\n- `GET /api/pages?route=/{locale}/path` → Page\n- `GET /api/pages/:id` → Page\n- `POST /api/pages` → create (validări SEO)\n- `PUT /api/pages/:id` → update (versioning + preview)\n- `GET /api/redirects` / `POST /api/redirects`\n- `GET /sitemap.xml` (runtime din `Page.status==='published'`)\n- `GET /robots.txt` (static din config)\n\n### Validări server\n- Title unic per (route, locale); ≤ 60 caractere\n- Description 140–160; non‑empty\n- CanonicalOverride: URL absolut, același domeniu\n- Hreflang: set complet ro/ru/en + x‑default pentru paginile cheie\n- OG/Twitter image: min 1200×630, < 512 KB\n- Schema JSON: parsabil și valid (minim câmpuri obligatorii pentru tip)\n- Redirect `from≠to`, `to` există/va exista\n\n### Generatoare\n- **Sitemap**: `changefreq=weekly`, `priority=0.8` (override din Page.seo)\n- **Robots**: Allow: `/`; Disallow: `/api/`, `/admin/`, `/draft/`\n\n### Observabilitate\n- audit trail (autor, data, diff)\n- preview tokens, expirați după 24h\n\n---\n\n## `/docs/admin-panel.md`\n\n### Obiectiv\nUI pentru editori: creare pagini per limbă, SEO tab cu validări live, blocuri de conținut cu preview.\n\n### Secțiuni UI\n1) **Lista pagini**\n   - Filtre: status, limbă, tip\n   - Căutare după route/title\n2) **Editor pagină** (tab‑uri)\n   - **Content**: gestionare `blocks` (drag&drop, add/remove)\n   - **SEO**: title/description/robots/canonical/OG/Twitter/hreflang/schema\n   - **Redirects** (pentru pagina curentă sau global)\n   - **Preview** (live, cu param `?preview=token`)\n\n### Tipuri de bloc (form schema)\n- `hero`: eyebrow, title, sub, ctaPrimary{label,href}, ctaSecondary{label,href}, image\n- `socialProof`: logos[], quote?, author?\n- `industriesPicker`: items[]{label, href}\n- `featuresGrid`: items[]{icon, title, text}\n- `integrations`: items[]{name, logo, href}\n- `pricingSnippet`: plans[]{name, price, currency, cta}\n- `faq`: items[]{q, a}\n- `ctaBanner`: title, sub, cta\n\n### Validări UI\n- Contor caractere pentru title/description\n- URL validator pentru canonical/CTA/hreflang\n- Imagine OG: dimensiune + raport 1200×630\n- Schema editor: JSON lint + preseturi `SoftwareApplication`, `Service`, `FAQPage`\n\n### Flux de lucru\n- Draft → Preview → Review (checklist) → Publish\n- Versionare automată; rollback din istorii\n\n### Checklist reviewer\n- Title/Desc ok, unice, fără trunchieri\n- Hreflang 1:1, canonical corect\n- OG/Twitter prezente\n- Min 3 interlink‑uri contextuale\n- CTA vizibil și funcțional\n\n---\n\n## `/docs/landing-b2b.md`\n\n### Scop\nHome/Landing B2B care poziționează EasyReserv ca platformă all‑in‑one și rutează vizitatorul către verticala potrivită.\n\n### Structură blocuri (ordine)\n1. **Hero** (headline + sub + CTA Trial/Demo + imagine)\n2. **Social Proof** (logo-uri clienți, citat scurt)\n3. **Industries Picker** (8 verticale principale)\n4. **Features Grid** (4–8 beneficii)\n5. **Integrations** (1C, plăți, imprimante, smartwatch etc.)\n6. **Pricing Snippet** (Basic €50, Standard €125, Pro €200 → /pricing)\n7. **FAQ** (5–7 întrebări BOFU)\n8. **CTA Banner** (Demo/Trial)\n\n### SEO pentru Landing\n- Title: „EasyReserv — Platformă all‑in‑one pentru rezervări, POS, operațiuni și analitică”\n- Description: „Automatizezi rezervările, POS, fluxurile operaționale și rapoartele. Integrezi plăți, contabilitate 1C, notificări și livrare — fără schimbare de hardware.”\n- Schema: `SoftwareApplication` + `FAQPage`\n- Hreflang: ro/ru/en + x‑default\n\n### Conținut minim (copy)\n- Headline: „Configurezi roluri, meniuri/servicii și pornești fluxurile în câteva ore”\n- Subheadline: „Automatizări care reduc timpii și cresc conversiile. Dashboarduri în timp real. Integrare contabilitate, plăți și notificări — fără schimbare de hardware.”\n- CTA: „Start Free Trial” / „Programează un demo”\n\n---\n\n## `/docs/seo-defaults.md`\n\n### Defaults (aplicate implicit dacă pagina nu are setări)\n- Title: generat din secțiune + brand (≤60)\n- Description fallback per secțiune (140–160)\n- Robots: `index,follow`\n- OG/Twitter: `summary_large_image`, imagine fallback `/og-default.jpg`\n- Canonical: absolut, format `{baseUrl}/{locale}/{slug}`\n- Hreflang: ro/ru/en + x‑default\n- Schema globală: `Organization`, `WebSite`, `BreadcrumbList`\n\n### Fișier TS recomandat\nFolosește `seo-defaults-easyreserv.ts` (helper pentru title, desc, canonical, hreflang, OG/Twitter, JSON‑LD, robots.txt, sitemap.xml).\n\n---\n\n## `/docs/content-model.md`\n\n### Tipuri de pagini\n- `home`, `pricing`, `industries`, `industry`, `feature`, `solutions`, `customers`, `case`, `blog`, `article`, `guides`, `calculators`, `help`, `about`, `contact`\n\n### Schema Page (rezumat)\n```ts\nPage {\n  id: string; route: string; locale: 'ro'|'ru'|'en'; slug: string;\n  status: 'draft'|'published'; seo: Seo; content: { blocks: Block[] }\n}\n```\n\n### Ancorare internă (interlinking)\n- Fiecare `industry` trebuie să lege către: `/pricing`, 2× `feature`, 1× `case`, 2× articole din blog din clusterul verticalei\n- `pricing` leagă către: `industries` + `contact`\n\n---\n\n## `/docs/routing-ia.md`\n\n### IA navigație\n- `/industries` → listă verticale\n- Verticale (slug EN, copy localizat):\n  - `/restaurants-pos-reservations`\n  - `/beauty-salon-barbershop`\n  - `/car-rental`\n  - `/sports-tennis-padel-football`\n  - `/car-wash`\n  - `/fitness-gyms`\n  - `/medical-clinics`\n  - `/retail`\n\n### Breadcrumbs\n`Acasă > Industrii > {Industrie}`\n\n### Redirecturi (exemple)\n- 301: vechiul `/restaurant` → `/restaurants-pos-reservations`\n\n---\n\n## `/docs/qa-checklist.md`\n\n### SEO & UX QA înainte de publish\n- [ ] Title unic (≤60), Description 140–160\n- [ ] Canonical corect; hreflang ro/ru/en + x‑default\n- [ ] OG/Twitter valide + imagine 1200×630 <512KB\n- [ ] Schema validă (`SoftwareApplication/Service/FAQPage` când e cazul)\n- [ ] 3–5 interlink‑uri contextuale/pagină + breadcrumbs\n- [ ] CTA vizibil, formular funcțional\n- [ ] CWV: LCP<2.5s, INP<200ms, CLS<0.1\n\n---\n\n## `/docs/examples/home.ro.md`\n\n### Meta\n- **Title**: EasyReserv — Platformă all‑in‑one pentru rezervări, POS, operațiuni și analitică\n- **Description**: Automatizezi rezervările, POS, fluxurile operaționale și rapoartele. Integrezi plăți, contabilitate 1C, notificări și livrare — fără schimbare de hardware.\n\n### Blocuri (JSON)\n```json\n{\n  \"blocks\": [\n    { \"type\": \"hero\", \"data\": { \"eyebrow\": \"All‑in‑one pentru rezervări, POS, operațiuni & analitică\", \"title\": \"Configurezi roluri, meniuri/servicii și pornești fluxurile în câteva ore\", \"sub\": \"Automatizări care reduc timpii și cresc conversiile. Dashboarduri în timp real. Integrare contabilitate, plăți și notificări — fără schimbare de hardware.\", \"ctaPrimary\": {\"label\":\"Start Free Trial\",\"href\":\"/ro/pricing\"}, \"ctaSecondary\": {\"label\":\"Programează un demo\",\"href\":\"/ro/contact\"}, \"image\": \"/hero-home.png\" } },\n    { \"type\": \"socialProof\", \"data\": { \"logos\": [\"/logos/pegas.svg\",\"/logos/steakhouse.svg\"], \"quote\": \"Am redus timpul de servire cu 22% în prima lună.\", \"author\": \"Manager restaurant\" } },\n    { \"type\": \"industriesPicker\", \"data\": { \"items\": [ {\"label\":\"Restaurante\",\"href\":\"/ro/restaurants-pos-reservations\"}, {\"label\":\"Saloane & Barbershop\",\"href\":\"/ro/beauty-salon-barbershop\"}, {\"label\":\"Chirie auto\",\"href\":\"/ro/car-rental\"}, {\"label\":\"Terenuri sportive\",\"href\":\"/ro/sports-tennis-padel-football\"} ] } },\n    { \"type\": \"featuresGrid\", \"data\": { \"items\": [ {\"icon\":\"kds\",\"title\":\"POS & KDS integrat\",\"text\":\"Comenzi sincronizate cu bucătăria și servirea.\"}, {\"icon\":\"bell\",\"title\":\"Notificări & SLA\",\"text\":\"Alerte pentru timpii de preparare și livrare.\"}, {\"icon\":\"chart\",\"title\":\"Analytics\",\"text\":\"Dashboarduri în timp real pe locație și perioadă.\"}, {\"icon\":\"link\",\"title\":\"Integrări\",\"text\":\"Plăți, 1C, imprimante, smartwatch.\"} ] } },\n    { \"type\": \"pricingSnippet\", \"data\": { \"plans\": [ {\"name\":\"Basic\",\"price\":50,\"currency\":\"EUR\",\"cta\":\"/ro/pricing\"}, {\"name\":\"Standard\",\"price\":125,\"currency\":\"EUR\",\"cta\":\"/ro/pricing\"}, {\"name\":\"Pro\",\"price\":200,\"currency\":\"EUR\",\"cta\":\"/ro/pricing\"} ] } },\n    { \"type\": \"faq\", \"data\": { \"items\": [ {\"q\":\"Cât durează onboarding-ul?\",\"a\":\"De regulă 1–3 zile în funcție de industrie și integrare.\"}, {\"q\":\"E compatibil cu hardware-ul meu?\",\"a\":\"Da, în majoritatea cazurilor nu e nevoie să schimbi echipamentul.\"} ] } },\n    { \"type\": \"ctaBanner\", \"data\": { \"title\":\"Pregătit să începi?\",\"sub\":\"Activează trialul sau programează un demo.\", \"cta\":\"/ro/pricing\" } }\n  ]\n}\n```\n\n---\n\n## `/docs/examples/pricing.ro.md`\n\n### Meta\n- **Title**: Prețuri & Planuri — EasyReserv\n- **Description**: Planuri pentru restaurante de la €50/lună. Trial gratuit inclus. Alege Standard sau Pro pentru funcții avansate și suport prioritar.\n\n### Conținut (secțiuni)\n- Planuri: Basic (€50), Standard (€125), Pro (€200), Enterprise (Contact)\n- Include: 2 utilizatori, Business Setup, Create Place, Reservations (toate planurile)\n- CTA: „Start Free Trial”\n- FAQ pricing (facturare, perioadă, upgrade/downgrade)\n\n---\n\n## `/docs/examples/industry.restaurants.ro.md`\n\n### Meta\n- **Title**: Restaurante: POS & Rezervări — EasyReserv\n- **Description**: Reduce timpii de servire, sincronizează bucătăria, gestionează rezervările și vezi rapoarte în timp real. Integrare 1C, plăți și notificări automate.\n\n### Secțiuni\n- Hero (beneficiu principal + CTA)\n- Probleme frecvente (latențe, erori comandă, no‑show)\n- Soluții EasyReserv (KDS, notificări, smartwatch, rezervări omnichannel)\n- ROI Calculator (micro‑widget) + studiu de caz scurt\n- Integrare 1C, plăți, hardware existent\n- CTA (Demo/Trial)\n\n","size_bytes":11077},"enpoints/auth.js":{"content":"const express = require('express');\nconst router = express.Router();\nconst User = require('../schemas/user');\nconst { protect, generateToken } = require('../middleware/auth');\n\nrouter.post('/api/account/register', async (req, res) => {\n  try {\n    const { email, password, role } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ message: 'Please provide email and password' });\n    }\n\n    const userExists = await User.findOne({ email });\n\n    if (userExists) {\n      return res.status(400).json({ message: 'User already exists' });\n    }\n\n    const user = await User.create({\n      email,\n      password,\n      role: role || 'user'\n    });\n\n    const serviceToken = generateToken(user._id);\n\n    res.status(201).json({\n      serviceToken,\n      user: {\n        id: user._id,\n        email: user.email,\n        role: user.role,\n        createdAt: user.createdAt\n      }\n    });\n  } catch (error) {\n    console.error('Register error:', error);\n    res.status(500).json({ message: 'Error creating user', error: error.message });\n  }\n});\n\nrouter.post('/api/account/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ message: 'Please provide email and password' });\n    }\n\n    const user = await User.findOne({ email });\n\n    if (!user) {\n      return res.status(401).json({ message: 'Invalid credentials' });\n    }\n\n    const isPasswordMatch = await user.comparePassword(password);\n\n    if (!isPasswordMatch) {\n      return res.status(401).json({ message: 'Invalid credentials' });\n    }\n\n    const serviceToken = generateToken(user._id);\n\n    res.json({\n      serviceToken,\n      user: {\n        id: user._id,\n        email: user.email,\n        role: user.role,\n        createdAt: user.createdAt\n      }\n    });\n  } catch (error) {\n    console.error('Login error:', error);\n    res.status(500).json({ message: 'Error logging in', error: error.message });\n  }\n});\n\nrouter.get('/api/account/me', protect, async (req, res) => {\n  try {\n    const user = await User.findById(req.user._id).select('-password');\n    \n    if (!user) {\n      return res.status(404).json({ message: 'User not found' });\n    }\n\n    res.json({\n      user: {\n        id: user._id,\n        email: user.email,\n        role: user.role,\n        createdAt: user.createdAt\n      }\n    });\n  } catch (error) {\n    console.error('Get user error:', error);\n    res.status(500).json({ message: 'Error fetching user', error: error.message });\n  }\n});\n\nmodule.exports = router;\n","size_bytes":2562}},"version":2}